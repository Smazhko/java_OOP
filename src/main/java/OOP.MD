## _Статические поля и методы_
***

СТАТИК - одно значение на ВСЕ экземпляры данного класса

    public static String StartLocation;

меняешь у базового - меняется у ВСЕХ наследников. 
Если поменять через один из наследников - будет изменено у всех наследников.
Доступ к полю обычно через название родительского класса - Character.StartLocation
может использоваться, например, для подсчёта ВСЕХ СОЗДАННЫХ героев - счётчик будет
ОБЩИЙ НА ВСЕ созданные экземпляры родительского класса

статический ИНИЦИАЛИЗАТОР поля или полЕЙ:
    
    static {
        StartLocation = "Talking Island";
    }

 Со СТАТИЧЕСКИМИ полями должны работать СТАТИЧЕСКИЕ методы.
 НЕстатические методы не могут быть вызваны из СТАТИЧЕСКИХ.
 Для СТАТИКИ нет иерархии - для вызывания статических полей и методов
 не нужно писать THIS или SUPER (статическое поле не принадлежит какому-то текущему 
 экземпляру класса).
 ТО ЕСТЬ обращение к статичесеким полям/методам происходит из базового класса,
 а не из его экземпляров.

при этом можно выбрать как видимость в текущем классе, так и видимость для 
экземпляров класса (дочерних, наследников)
    
    public    - доступность ВСЕМ и ВЕЗДЕ
    protected - доступность данному классу и его наследникам
    private   - недоступность только внутри текущего класса

использование СТАТИКИ можно обойти разными способами. если без неё можно - 
лучше обойтись

## _Абстрактные классы и методы_
***

        public abstract class BaseCharacter {}

public abstract class - АБСТРАКТНЫЙ КЛАСС. не даёт создавать экземпляры самого себя
и служит только РОДИТЕЛЕМ для других классов, являясь для них схемой и реализацией
по умолчанию

В абстарктном классе могут быть абстрактные методы БЕЗ реализации.

    public abstract void die()

При этом в логику абстрактного класса эти методы могут быть включены (несмотря на
то, что метод объявлен, но не реализован, его вызов может быть сделан из соседних
методов).


Реализация таких абстрактных методов должны быть ОБЯЗАТЕЛЬНОЙ для всех НАСЛЕДНИКОВ
абстр класса
иначе программа не скомпилируется


## _Наследование_
***
    
    class Foo{}
    
    class Doo extends Foo{}
    
так класс Doo является наследником класса Foo (Doo расширяет класс Foo)

    BASE HERO  - базовый класс
    
    DRUID      - наследуется от BASE HERO

    public abstract class BaseHero{}
    public class Druid extends BaseHero{}
    public class Dwarf extends Druid{}

    BaseHero dwarf = new Dwarf();

даункаст: если от BaseHero уходить в Druid    
если нужно подняться по иерархии вверх - АпКаст (друида можно представить 
в виде экземпляра класса BaseHero)
    
    DWARF      - наследуется от DRUID (даункаст от Druid)

Если создать экземпляр класса DRUID, то его нельзя привести к типу DWARF 
(нельзя сделать даункаст
без предварительного апкаста - НЕПОНЯТНО)

НО
экземпляр класса DWARF можно АпКастить до класса DRUID и, если необходимо, 
до класса BASE HERO

При вызывании конструктора класса наследника (2е поколение)
1. Сначала вызываются все его собственные констуркторы по мере необходимости. 
Если в них использовался конструктор SUPER(), то...
2. Затем вызывается конструктор класса-родителя (класс 1го поколения), 
и если в нём использовался конструктор SUPER базового класса, то 
3. В конце концов вызывается конструктор БАЗОВОГО класса (0-е поколение).
4. Затем курсор выполнения процесса возвращается по восходящей 
к классу 2го поколения, выполняя по ходу все действия во всех конструкторах 
на пути - как в рекурсии (возвращение по стеку вызовов)

Alt + Insert -> Constructor

## _Интерфейсы_
***

`Interface` предназначен для описания исключительно общего поведения сущностей.

> Частный случай: для гарантии, реализации некоторого
поведения.

**Интерфейс** – это частный случай класса. Он представляет собой полностью абстрактный
класс с абстрактными членами.



