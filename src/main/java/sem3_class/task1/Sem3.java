/*
методы в интерфейсах могут быть:
- абстрактными (все методы интерфейса, словом abstract не выделаются): не определяет никакого поведения, носит
    только декларативный характер
- по умолчанию (default): должен быть реализован в интерфейсе, наследуется всеми классами, реализующими интерфейс,
    где может быть (но не должен быть) переопределён
- статическими (static): должен быть реализован в интерфейсе, доступ у нему обеспечивается из САМОГО интерфейса,
    а не из класса, реализающего этот интерфейс. НЕ МОЖЕТ быть переопределён.

функциональный интерфейс - интерфейс обозначающий ТОЛЬКО ОДНУ функцию (содержит только 1 АБСТРАКТНЫЙ метод)

чаще всего реализация функционального интерфейса происходит в помощью ЛЯМБДА-выражений
для этого необходимо создать экземпляр интерфейса (!)
(это делается потому, что мы не имплементируем желаемый функциональный интерфейс в класс в котором работаем)
1. сначала объявляется ссылка на функциональный интерфейс
2. затем этой ссылке присваивается ЛЯМБДА (выражение РЕАЛИЗУЕТ тот самый ЕДИНСТВЕННЫЙ абстрактный метод)
        IMyValue value;
        value = () -> 98.6;
данная ЛЯМБДА согласуется с методом double getValue() в интерфейсе IMyValue, так как имеет тип double
поэтому при вызове абстрактного метода функц интерфейса мы получим результат выполнения лямбды


если в интерфейсе метод должен принимать какие-то значения, то и в скобках ЛЯМБДЫ надо указать эти зачения

interface IMyValue {double getValue(double num);}

value = (n) -> 98.6 / n;

|  ВАЖНО!
|  Перегрузка методов в интерфейсе невозможна. Поэтому для того, чтобы в выражение закинуть разное количество
|  переменных, пришлось создать ДРУГОЙ интерфейс с таким же незванием метода.

Используя один и тот же интерфейс, можно реализовывать его различными ЛЯМБДАМИ
При этом никак НЕЛЬЗЯ поменять количество и тип передаваемых в ЛЯМБДУ переменных.

!!! ЛЯМБДЫ созданы для реализации ФУНКЦИОНАЛЬНЫХ ИНТЕРФЕЙСОВ - эти две вещи всегда работают вместе

ЛЯМБДА - по сути анонимный метод:

(список аргументов через запятую) -> (выражение с этими аргументами)

ИЛИ блочный вариант (для реализации большой логики):

(список аргументов через запятую) -> {
        выражение с этими аргументами;
        return РЕЗУЛЬТАТ;}

даже таким длинным способом ЛЯМБДА затратит меньше ресурсов, чем если бы всё это реализовывалось через
создание отдельных классов и методов
*/

package sem3_class.task1;


public class Sem3 {

    public static void main(String[] args) {
        IMyValue1 value1;
        value1 = (m, n) -> m / n;
        System.out.println(value1.getValue(11.5, 2.0));


        IMyValue2 value2;
        value2 = (m) -> 50 * m;
        System.out.println(value2.getValue(2.5));


        IMyValue1 value3;
        value3 = (m, n) -> m + n;
        System.out.println(value3.getValue(5.3, 4.8));

        IMyValue1 value4;
        value4 = (m, n) -> m * n;
        System.out.println(value4.getValue(10, 2));

    }


}
