Урок 6. ООП Дизайн и Solid
Взять реализованный код в рамках семинара 3 , 4 или 5 
и продемонстрировать применение принципов, 
усвоенных на семинаре.
Нужно в проекте прокомментировать участки кода, 
которые рефакторим, какой принцип применяем и почему.

Формат сдачи: ссылка на гитхаб проект


==============================================

реализация [S] в SOLID
Принцип единственной ответственности — The Single Responsibility Principle или SRP
Принцип декларирует, что каждый объект должен иметь одну обязанность и эта обязанность
должна быть полностью инкапсулирована в класс, а все его сервисы должны быть
направлены исключительно на обеспечение этой обязанности.

из классов КНИГА, ПЕРИОДИКА выделены независимые узкоспециализированные методы 
(как часть функционального интерфейса) для показа информации об издании IGetPeriodicalInfo и IGetBookInfo.
Таким образом, для изменения вывода информации в консоль не нужно будет редактировать основной класс

==============================================

Принцип открытости/закрытости — The Open Closed Principle или OCP
Принцип декларирует, что программные сущности (классы, модули, функции и т. п.)
должны быть открыты для расширения, но закрыты для изменения. Это означает,
что эти сущности могут менять свое поведение без изменения их исходного кода.
В этом контексте открытость для расширения — это возможность добавить для класса,
модуля или функции новое поведение, если необходимость в этом возникнет,
а закрытость для изменений — это запрет на изменение исходного кода программных сущностей.

В классах ARTBOOK и SCIENCEBOOK наследниках класса BOOK заменён метод getKind
таким образом, НЕ изменяя класс-родитель, мы меняем поведение класса-наследника

==============================================

Принцип подстановки Барбары Лисков — The Liskov Substitution Principle или LSP
Принцип в формулировке Роберта Мартина декларирует, что функции, которые используют базовый тип,
должны иметь возможность использовать подтипы базового типа не зная об этом.
Следование принципу LSP заключается в том, что при построении иерархий наследования создаваемые
наследники должны корректно реализовывать поведение базового типа. То есть если базовый тип
реализует определённое поведение, то это поведение должно быть корректно реализовано и для
всех его наследников.

Классы ARTBOOK и SCIENCEBOOK наследники класса BOOK
реализуют методы родительского класса.
Благодаря этому:
 - возмножно "положить" в класс КНИЖНАЯ ПОЛКА BOOKSHELF экземпляры любых наследуемых от BOOK классов
 - работают отдельно выделенные методы из IGetPeriodicalInfo и IGetBookInfo (не зависят от типа 
 - передаваемых объектов)

==============================================

Принцип разделения интерфейса — The Interface Segregation Principle или ISP

Клиенты не должны зависеть от методов, которые они не используют. То есть если какой‑то метод 
интерфейса не используется клиентом, то изменения этого метода не должны приводить к необходимости 
внесения изменений в клиентский код.

Следование принципу ISP заключается в создании интерфейсов, которые достаточно специфичны и требуют 
только необходимый минимум реализаций методов. Избыточные интерфейсы, напротив, могут требовать от 
реализующего класса создание большого количества методов, причём даже таких, которые не имеют смысла 
в контексте класса

Из интерфейса IBasePublication вынесен функциональный узкоспецифичный интерфейс IChangeAvailability, 
меняющий доступность той или иной публикации (любого класса).

==============================================

Принцип инверсии зависимостей — The Dependency Inversion Principle или DIP
Принцип декларирует, что модули верхних уровней не должны зависеть от модулей нижних уровней, 
а оба типа модулей должны зависеть от абстракций; сами абстракции не должны зависеть от деталей, 
а вот детали должны зависеть от абстракций.

Следование принципу инверсии зависимостей «заставляет» реализовывать высокоуровневые компоненты 
без встраивания зависимостей от конкретных низкоуровневых классов, что, например, сильно упрощает 
замену используемых зависимостей как по бизнес‑требованиям, так и для целей тестирования. При этом 
зависимость формируется не от конкретной реализации, а от абстракции — реализуемого зависимостью интерфейса.


