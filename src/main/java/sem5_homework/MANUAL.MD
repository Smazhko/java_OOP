1 - Конструируем калькулятор, применяя архитектуру MVP (Model-View-Presenter), с возможностью выполнения базовых
математических операций, таких как сложение, вычитание, умножение и деление, работающий с дробными числами.
Доп. Задача (*) Мы также обеспечим обработку возможных ошибок, чтобы предотвратить некорректные операции.

2- По Желанию *.  
МОДЕЛЬ (Model): Создайте класс User для представления учетной записи пользователя. Этот класс будет содержать
поля для имени, логина и пароля пользователя, а также методы доступа к этим полям. Модель также может содержать методы
для сохранения и загрузки данных пользователя.

ПРЕДСТАВЛЕНИЕ (View): Создайте класс UserView, который будет отвечать за отображение информации о пользователе и
взаимодействие с пользователем. Этот класс будет содержать методы для отображения формы регистрации, формы входа,
формы изменения пароля и т.д. Он также будет содержать методы для получения введенных пользователем данных.

ПРЕЗЕНТЕР (Presenter): Создайте класс UserPresenter, который будет служить посредником между моделью и представлением.
Презентер будет содержать ссылку на модель и представление, и будет обрабатывать пользовательские действия, такие как
регистрация, вход, изменение пароля и т.д. Он будет вызывать соответствующие методы модели для выполнения операций и
обновлять представление с помощью методов представления для отображения результатов.

Главный класс приложения: Создайте главный класс UserManagementApp, который будет являться точкой входа в приложение.
В этом классе вы можете создать экземпляр модели, представления и презентера, и установить связь между ними. Например,
вы можете передать ссылку на модель и представление в конструктор презентера.

В результате, при выполнении операций, таких как регистрация, вход, изменение пароля, пользовательский интерфейс будет
взаимодействовать с презентером, презентер будет обращаться к модели для выполнения операций и обновлять представление
с помощью методов представления.

Такая архитектура помогает разделить ответственность между компонентами приложения, облегчает тестирование и поддержку
кода, а также позволяет легче масштабировать и расширять функциональность в будущем.


============================================================
Разберем, как должны взаимодействовать компоненты MVP друг с другом.

В архитектуре MVP (Model-View-Presenter), каждый компонент выполняет свою роль:

Модель (Model): Это слой, отвечающий за обработку данных и бизнес-логику приложения. Модель содержит данные и методы
для их обработки. Она не зависит от представления или презентера.

Представление (View): Это слой, отвечающий за отображение данных пользователю и обработку пользовательского ввода.
Представление пассивно и не содержит бизнес-логики. Оно только отображает данные, полученные от презентера, и передает
пользовательский ввод обратно презентеру.

Презентер (Presenter): Это слой, который связывает модель и представление. Презентер получает пользовательский ввод
из представления, обрабатывает его и обновляет модель. Затем он получает обновленные данные из модели и передает их
обратно представлению для отображения. Презентер также может обрабатывать другие события и обновлять представление
соответствующим образом.

Таким образом, взаимодействие между компонентами MVP выглядит примерно следующим образом:

Пользователь взаимодействует с ПРЕДСТАВЛЕНИЕМ (VIEW) (например, вводит данные в текстовые поля или нажимает кнопки).

ПРЕДСТАВЛЕНИЕ (VIEW) передает полученные данные или события ПРЕЗЕНТЕРУ.

ПРЕЗЕНТЕР обрабатывает данные или события, выполняет необходимые операции (например, обновляет МОДЕЛЬ) и получает
обновленные данные из МОДЕЛИ.

ПРЕЗЕНТЕР передает обновленные данные ПРЕДСТАВЛЕНИЮ (VIEW).

ПРЕДСТАВЛЕНИЕ (VIEW) обновляет свое состояние, отображает полученные данные пользователю.

Т.о., презентер является посредником между моделью и представлением, обеспечивая обмен данными и обработку событий.
Модель и представление взаимодействуют только с презентером и не имеют прямого взаимодействия друг с другом.


===========================================================
```java
// Модель (Model) *******************************************************
public class CalculatorModel {
    private int result;
    
    public void add(int number1, int number2) {
    result = number1 + number2;
    }
    
    public int getResult() {
        return result;
    }
}

// Представление (View) **************************************************
public class CalculatorView {
    public void displayResult(int result) {
        System.out.println("Результат: " + result);
    }

    public int getUserInput() {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Введите число: ");
        int input = scanner.nextInt();
        return input;
    }
}

// Презентер (Presenter) ***************************************************
public class CalculatorPresenter {
    private CalculatorModel model;
    private CalculatorView view;

    public CalculatorPresenter(CalculatorModel model, CalculatorView view) {
        this.model = model;
        this.view = view;
    }
    
    public void onAddButtonClicked() {
        int number1 = view.getUserInput();
        int number2 = view.getUserInput();
        
        model.add(number1, number2);
        int result = model.getResult();
        
        view.displayResult(result);
    }
}

// Главный класс приложения *************************************************
public class Main {
    public static void main(String[] args) {
        // Создание экземпляров модели, представления и презентера
        CalculatorModel model = new CalculatorModel();
        CalculatorView view = new CalculatorView();
        CalculatorPresenter presenter = new CalculatorPresenter(model, view);

        // Обработка действия пользователя (например, нажатие кнопки "Сложить")
        presenter.onAddButtonClicked();
    }
}
```
===========================================================


В этом примере:
> * модель (CalculatorModel) выполняет операции сложения чисел,
> * представление (CalculatorView) отображает результаты и запрашивает ввод от пользователя,
> * а презентер (CalculatorPresenter) связывает модель и представление, обрабатывает пользовательский ввод
и обновляет состояние модели и представления.

При запуске приложения, метод onAddButtonClicked в презентере вызывается для обработки действия пользователя.
Презентер запрашивает два числа от представления, передает их в модель для выполнения операции сложения,
получает результат из модели и передает его обратно представлению для отображения.

Это простой пример, и в реальных приложениях взаимодействие компонентов MVP может быть более сложным и содержать
больше операций и логики. Но основная идея остается той же - модель, представление и презентер взаимодействуют между
собой, чтобы обеспечить разделение ответственностей и улучшить поддерживаемость и тестируемость приложения.

Надеюсь, этот пример поможет Вам)

===========================================================

MVC (Model-View-Controller) и MVP (Model-View-Presenter) - это два варианта организации архитектуры программы для 
достижения цели разделения логики приложения на три компонента: модель, представление и контроллер (или презентер в 
случае MVP). Ниже я объясню сходства и различия между ними:
____________________________
**_Сходства:_**

* Разделение ответственности: Оба паттерна стремятся к разделению кода на логические компоненты, чтобы облегчить 
понимание и поддержку кода.

* Изоляция бизнес-логики: В обоих случаях бизнес-логика приложения находится в отдельных компонентах (модель или 
презентер), тогда как представление занимается только отображением данных.

* Снижение связанности: Оба паттерна помогают уменьшить зависимость между различными частями кода.
____________________________

**_Различия_**:

* Роль контроллера/презентера: В паттерне MVC контроллер (или презентер в MVP) играет роль координатора между моделью 
и представлением. Он обрабатывает пользовательский ввод и управляет обновлением данных и отображения. В MVP презентер 
активно управляет взаимодействием между моделью и представлением, тогда как в MVC контроллер более нейтрален и иногда 
может также выполнять другие задачи, не связанные с взаимодействием.

* Тестирование: MVP обычно считается более тестируемым, так как большая часть бизнес-логики находится в презентере, 
который можно легко тестировать независимо от пользовательского интерфейса. В MVC тестирование контроллера может 
быть более сложным из-за его тесной связи с представлением.

* Обновление интерфейса: В MVP представление пассивно и получает обновления данных от презентера. В MVC представление 
может иметь более активную роль в обновлении, что может быть полезным для некоторых сценариев.

* В конечном итоге, какой паттерн использовать зависит от требований проекта и личных предпочтений. Оба подхода 
помогут вам организовать код таким образом, чтобы он был легко понимаемым, расширяемым и тестируемым.
*****************************************
Тэ Зэ
приветствие
главное меню
выбор: войти / зарегистриоваться / выйти

1. войти
    - показ меню входа
    - ввод логина
    - проверка логина
        * если логин есть, то ничего не делать
        * если логина нет -
            + сообщить об ошибке,
            + предложить повторно ввести / зарегистироваться / выйти в главное меню
    - ввод пароля
    - проверка пароля на соответствие логину
        * если совпадает, то вход в систему:
            + создание CURRENTUSER - юзер из списка
            + показ меню пользователя
        * если не совпадает:
            + сообщить об ошибке
            + предложить повторно ввести / выйти в главное меню

2.зарегистрироваться
    - показ меню регистрации
    - ввод логина
    - проверка логина
        * можно исп только буквы цифры
        * если уже есть - предложить придумать новый
        * если нет - ничего не делать
    - ввод пароля
    - проверка пароля на валидность
        * можно исп только буквы цифры
    - ввод имени
    - создание объекта ЮЗЕР
    - добавление ЮЗЕРа в общий список
    - сохранение общего списка в файл
    - сообщение - регистрация успешна
ВОЗВРАТ в главное меню

3. меню пользователя - работа с CurrentUser:
   1) "Изменить имя"
       - ввод имени
           * проверка на валидность - можно исп только буквы, цифры
       - изменение имени через СЕТ
       - поиск в общем списке по логину - замена старого юзера на новый
       - сохранение нового общего списка в файл
   2) "Изменить пароль"
       - ввод пароля
           * проверка на валидность - можно исп только буквы, цифры
       - изменение пароля через СЕТ
       - сохранение нового общего списка в файл
   3) "Выйти из учётной записи"
       - CurrentUser = null
       - показать главное меню
   4) "Удалить учётную запись"
       - удалить запись с логином CurrentUser из списка
       - CurrentUser = null
       - показать главное меню
   5) "Выйти из программы"
       - выход
